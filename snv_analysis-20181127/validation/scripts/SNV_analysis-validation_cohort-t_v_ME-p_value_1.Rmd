---
title: "Analysis of mutations in GZL exomes"
author: "Stacy Hung"
output:
  pdf_document: default
  html_notebook: default
---

To avoid memory errors, files have been pre-filtered using the following thresholds:
* Mutect  - predictions that have a "KEEP" flag (i.e. remove those that have a "REJECT" flag)
* Strelka - "passed" predictions (passed.somatic.snvs.vcf, passed.somatic.indels.vcf)
* VarScan - removal of predictions labelled with the effect "INTRON", "INTRAGENIC", "\tSYNONYMOUS_CODING"

Additional filters that should be applied to VarScan calls (through R):
1. SS = 2 (somatic based on Fisher's exact test) and GMAF (if available) < 0.01
2. dbSNP as a filter?? (yes, for unpaired tumor samples analyzed using a VarScan singles pipeline)

NEW thresholds / filters (for SNV calling only):
*1. Only keep variants with a somatic p-value < 0.05
*2. Minimum variant reads = 3
*3. Minimum allele frequency = 5%
*4. Maximum 5% tumor contamination in normal

**Since we are using a new pipeline, we should also check that the strand bias filter is working

Specific changes to ensure consistency of tumor IDs (auto-)generated by each tool:
- VarScan: change "_GZ" to "-GZ" so that tumor_normal would be identified as tumor-normal
- Since MuTect tumor ids were truncated to not include the ".markDups" suffix, this needed to be removed from the VarScan and Strelka tumor ids

## ###############################################################################################
## Load and process datasets for paired T-N analysis (VarScan paired, MuTect, Strelka)
## ###############################################################################################

```{r}
library(dplyr)    # filter
library(tidyr)    # separate
```

```{r}
#**************
#*  VARSCAN   *
#**************
varscan.paired.snvs <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/validation/varScan.paired.pvalue_1/all.paired_samples.varScan.snps.filtered.txt", sep = "\t", header = TRUE, fill = TRUE)
varscan.paired.indels <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/validation/varScan.paired.pvalue_1/all.paired_samples.varScan.indels.filtered.txt", sep = "\t", header = TRUE, fill = TRUE)

# combine snvs and indel - add mutation type as separate "type" column
varscan.paired.snvs$type = "snv"
varscan.paired.indels$type = "indel"
varscan.paired.calls <- rbind(varscan.paired.snvs, varscan.paired.indels)

rm(varscan.paired.snvs)
rm(varscan.paired.indels)

# rename columns
colnames(varscan.paired.calls) <- c("sample", "chr", "pos", "external_id", "ref", "alt", "qual", "filter",
                            "depth", "somatic_status", "ssc", "gpv", "somatic_p_value", "cda",
                            "KG_validated", "om", "pm", "gmaf", "gt_normal", "gt_tumor", "gq_normal", "gq_tumor",
                            "depth_normal", "depth_tumor", "ref_reads_normal", "ref_reads_tumor",
                            "var_reads_normal", "var_reads_tumor", "allele_freq_normal", "allele_freq_tumor",
                            "depth4_normal", "depth4_tumor", "effect", "impact", "fun_class", "HGVS_DNA",
                            "HGVS_protein", "gene", "biotype", "coding", "transcript_id", "exon_rank", "type")

# create a tumor_id column based on the sample id (format is <tumor_id>_<normal_id>) - e.g. GE0556B_GE0556-N
varscan.paired.calls$tumor_id <- gsub("(.*)\\_GZ(.*)","\\1", varscan.paired.calls$sample)
# after merging with strelka calls, we will need to remove the scroll identifier (e.g. A, B, etc.)

# remove ".markDups" from the tumor ids
varscan.paired.calls$tumor_id <- gsub("(.*)\\.markDups(.*)","\\1", varscan.paired.calls$tumor_id)

# remove "%" from the allele frequency
varscan.paired.calls$allele_freq_normal <- gsub("(.*)\\%(.*)","\\1", varscan.paired.calls$allele_freq_normal)
varscan.paired.calls$allele_freq_tumor <- gsub("(.*)\\%(.*)","\\1", varscan.paired.calls$allele_freq_tumor)

# filter for somatic calls (SS = 2 and GMAF [if available] is not greater than 0.01)
#varscan.paired.calls <- filter(varscan.paired.calls, somatic_status == 2 & filter == 'PASS' & (as.numeric(gmaf) < 0.01 | is.na(gmaf)))

# filter calls based on somatic p-value
#varscan.paired.calls <- filter(varscan.paired.calls, as.numeric(somatic_p_value) <= 0.05)

# filter calls based on minimum variant reads
#varscan.paired.calls <- filter(varscan.paired.calls, as.numeric(var_reads_tumor) >= 3)

# filter calls based on minimum allele frequency
#varscan.paired.calls <- filter(varscan.paired.calls, as.numeric(allele_freq_tumor) >= 5)

# filter on maximum 5% of tumor reads in tumor
#varscan.paired.calls <- filter(varscan.paired.calls, as.numeric(allele_freq_normal) <= 0.05*as.numeric(var_reads_tumor))

# remove unneeded columns and rearrange as necessary
# last few columns are for initial filtering and reference and can be removed later
keeps <- c("tumor_id", "type", "chr", "pos", "gene", "ref", "alt", "HGVS_DNA", "HGVS_protein",
           "allele_freq_normal", "allele_freq_tumor", "depth4_normal", "depth4_tumor", 
           "var_reads_normal", "var_reads_tumor", "effect", "impact", "fun_class", "transcript_id",
           "external_id", "somatic_p_value", "somatic_status", "gt_normal", "gt_tumor", "gmaf", "somatic_status")
varscan.paired.calls <- varscan.paired.calls[keeps]

# filter HGVS calls for obvious effects
varscan.paired.calls <- unique(rbind(
                varscan.paired.calls[grep("FRAME_SHIFT", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("SPLICE_SITE_ACCEPTOR", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("SPLICE_SITE_DONOR", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("CODON_CHANGE_PLUS_CODON_DELETION", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("CODON_DELETION", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("CODON_INSERTION", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("NON_SYNONYMOUS_CODING", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("NON_SYNONYMOUS_START", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("START_GAINED", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("START_LOST", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("STOP_GAINED", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("STOP_LOST", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("UTR_3_PRIME", varscan.paired.calls$effect), ],
                varscan.paired.calls[grep("UTR_5_PRIME", varscan.paired.calls$effect), ]
                ))

# other effects to include:
# SPLICE_SITE_REGION ? [IMPACT: LOW] - desc: A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron.
# EXON ? [IMPACT: MODIFIER] - desc: The variant hits an exon (from a non-coding transcript) or a retained intron.
# SYNONYMOUS_STOP? [IMPACT: LOW] - desc: Variant causes stop codon to be mutated into another stop codon. e.g.: taA/taG, */*

# filter for out obvious polymorphisms (GMAF > 1%)
varscan.paired.calls <- filter(varscan.paired.calls, as.numeric(gmaf) < 0.01  | is.na(gmaf))

varscan.paired.calls$combine = as.character(paste(
  varscan.paired.calls$tumor_id, 
  varscan.paired.calls$chr, 
  varscan.paired.calls$pos, 
  varscan.paired.calls$ref,
  varscan.paired.calls$alt,
  sep = "."
  ))

# sort the calls by case, chr, then position
varscan.paired.calls <- arrange(varscan.paired.calls, tumor_id, chr, pos)

# print out the results (these will be VarScan not intersected with any other methods)
write.table(varscan.paired.calls, "/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/validation/varScan.paired.pvalue_1/varScan.all.paired-snps_and_indels.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

```{r}
#**************
#*   MUTECT   *
#**************

# NB: the raw output file first needs to be cleaned up (includes extra headers from every tumor file), and will also include file names from performing an egrep on multiple files.  This can be done quickly in the command line environment.
mutect.snvs <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/not_validation/mutect/mutect.all.snps.pass.txt", sep = "\t", header = TRUE)

mutect.snvs$combine = as.character(paste(
  mutect.snvs$tumor_name,
  mutect.snvs$contig,
  mutect.snvs$position,
  mutect.snvs$ref_allele,
  mutect.snvs$alt_allele,
  sep = "."
))

mutect.snvs$type = "snv"
```

```{r}
#**************
#*  STRELKA   *
#**************
strelka.snvs <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/not_validation/strelka/passed.snvs.txt", sep = "\t", header = FALSE)
strelka.indels <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/not_validation/strelka/passed.indels.txt", sep = "\t", header = FALSE)

# combine snvs and indels - add mutation type as separate "type" column
strelka.indels$type = "indel"
strelka.snvs$type = "snv"
strelka.calls <- rbind(strelka.indels, strelka.snvs)

rm(strelka.indels)
rm(strelka.snvs)

# extract only columns of interest
strelka.calls <- strelka.calls[,c("V1", "V2", "V3", "V5", "V6", "type")]

# assign column names to strelka datasets
colnames(strelka.calls) <- c("sample", "chr", "pos", "ref", "alt", "type")

# remove ".markDups" from the tumor ids
strelka.calls$sample <- gsub("(.*)\\.markDups(.*)","\\1", strelka.calls$sample)

strelka.calls$combine = as.character(paste(
  strelka.calls$sample,
  strelka.calls$chr,
  strelka.calls$pos,
  strelka.calls$ref,
  strelka.calls$alt,
  sep = "."
))
```

```{r}
#****************************************
#*  COMBINE VARSCAN + MUTECT + STRELKA  *
#****************************************

# !!!NEW!!!

# We want to look at all variants that meet the following criteria:
# 1. Occur in the intersection of VarScan + Strelka... OR
# 2. Occur in the intersection of VarScan + MuTect... OR
# 3. Occur in the intersection of Strelka + MuTect
# Any of the above cases may also include mutations that fall into the intersection of all 3 tools.
# Remove duplicates (e.g. intersection of all three)

# VarScan + Strelka (SNVs only)
#varScan.snvs <- subset(varscan.paired.calls, varscan.paired.calls$type == 'snv')
#combine.varscan.intersect.strelka <- intersect(unique(varScan.snvs$combine), unique(strelka.calls$combine))
#snvs.varScan.strelka <- subset(varscan.paired.calls, varscan.paired.calls$combine %in% combine.varscan.intersect.strelka)
#snvs.varScan.strelka$evidence <- "varscan, strelka"
#
## VarScan + MuTect (SNVs only)
#combine.varscan.intersect.mutect <- intersect(unique(varScan.snvs$combine), unique(mutect.snvs$combine))
#snvs.varScan.mutect <- subset(varscan.paired.calls, varscan.paired.calls$combine %in% combine.varscan.intersect.mutect)
#snvs.varScan.mutect$evidence <- "varscan, mutect"
#
## Now look for mutations that overlap between all tools
#combine.all <- intersect(unique(combine.varscan.intersect.mutect), unique(snvs.varScan.strelka$combine))
#calls.intersect.all <- subset(varscan.paired.calls, varscan.paired.calls$combine %in% combine.all)
#calls.intersect.all$evidence <- "varscan, mutect, strelka"
#
## MuTect + Strelka -- we will omit these for now since they are more noisy than when combining with VarScan
##combine.mutect.intersect.strelka <- intersect(unique(mutect.snvs$combine), unique(strelka.calls$combine))
##snvs.mutect.strelka <- subset(mutect.snvs, mutect.snvs$combine %in% combine.mutect.intersect.strelka)
#
#calls.2_tools.all <- unique(rbind(snvs.varScan.mutect, snvs.varScan.strelka))
#
## remove all calls labelled as part of "VarScan + Strelka" OR "VarScan + MuTect" that are in the full intersect
#temp <- subset(calls.2_tools.all, !(calls.2_tools.all$combine %in% combine.all) )
## then add calls from the original varScan dataset that are present in the full intersection
#calls.all <- unique(rbind(temp, calls.intersect.all))


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# The below code is for finding only the intersection of all three tools:

# Find the intersection of varscan (snvs), mutect, and strelka (snvs).
combine.varscan.intersect.strelka <- intersect(unique(varscan.paired.calls$combine), unique(strelka.calls$combine))
combine.intersect.all <- intersect(unique(combine.varscan.intersect.strelka), unique(mutect.snvs$combine))
snvs.intersect.all <- subset(varscan.paired.calls, varscan.paired.calls$combine %in% combine.intersect.all)
snvs.intersect.all$evidence <- "mutect, strelka, varscan"
#
# add indels
# Take the intersect of indels from varscan and strelka indel calls.
varscan.indels <- subset(varscan.paired.calls, varscan.paired.calls$type == 'indel')
strelka.indels <- subset(strelka.calls, strelka.calls$type == 'indel')
combine.varscan.intersect.strelka <- intersect(unique(varscan.indels$combine), unique(strelka.indels$combine))
indels.intersect.all <- subset(varscan.paired.calls, varscan.paired.calls$combine %in% combine.varscan.intersect.strelka)
indels.intersect.all$evidence <- "strelka, varscan"

# now combine snvs and indels
calls.all <- rbind(snvs.intersect.all, indels.intersect.all)

rm(varscan.paired.calls)
rm(strelka.calls)
rm(mutect.snvs)
rm(combine.varscan.intersect.strelka)
#rm(combine.intersect.all)
#rm(snvs.intersect.all)
#rm(varscan.indels)
#rm(strelka.indels)
#rm(indels.intersect.all)

# remove NA's and blanks for functional class
calls.all$fun_class[calls.all$fun_class==""] <- "NONE"
calls.all$fun_class[is.na(calls.all$fun_class)] <- "NONE"

# remove the "combine" and "tumor_id" column, and rearrange columns in the process
keeps <- c("tumor_id", "type", "chr", "pos", "gene", "ref", "alt", "HGVS_DNA", "HGVS_protein",
           "allele_freq_normal", "allele_freq_tumor", "depth4_normal", "depth4_tumor", 
           "var_reads_normal", "var_reads_tumor", "effect", "impact", "fun_class", "transcript_id",
           "external_id", "somatic_p_value", "somatic_status", "gt_normal", "gt_tumor", "evidence")

calls.all <- calls.all[keeps]

# sort the calls by case, chr, then position
calls.all <- unique(arrange(calls.all, tumor_id, chr, pos))

# write the results to a text file
write.table(calls.all, "/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/not_validation/snvs.all.intersect.txt", sep = "\t", quote = FALSE, row.names = FALSE)

```

## ###############################################################################################
## Visualization
## ###############################################################################################

```{r}
library(plyr)
library(ggplot2)

calls.all <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/not_validation/snvs.all.intersect.txt", sep = "\t", header = TRUE, fill = TRUE)

calls.all$class <- revalue(calls.all$effect, c("NON_SYNONYMOUS_CODING"="Missense", 
                           "NON_SYNONYMOUS_START"="Missense",
                           "START_LOST"="Start Lost",
                           "STOP_LOST"="Missense",
                           "STOP_GAINED"="Nonsense",
                           "CODON_CHANGE_PLUS_CODON_DELETION"="In-frame Indel",
                           "CODON_CHANGE_PLUS_CODON_INSERTION"="In-frame Indel",
                           "CODON_DELETION"="In-frame Indel",
                           "CODON_INSERTION"="In-frame Indel",
                           "FRAME_SHIFT"="Frameshift Indel",
                           "FRAME_SHIFT+SPLICE_SITE_ACCEPTOR"="Frameshift Indel",
                           "FRAME_SHIFT+SPLICE_SITE_DONOR"="Frameshift Indel",
                           "FRAME_SHIFT+STOP_GAINED"="Frameshift Indel",
                           "SPLICE_SITE_ACCEPTOR+CODON_CHANGE_PLUS_CODON_DELETION"="In-frame Indel",
                           "SPLICE_SITE_DONOR+CODON_CHANGE_PLUS_CODON_DELETION"="In-frame Indel",
                           "STOP_LOST+CODON_DELETION"="In-frame Indel",
                           "SPLICE_SITE_ACCEPTOR"="Splice site",
                           "SPLICE_SITE_DONOR"="Splice site",
                           "UTR_3_PRIME"="3' UTR",
                           "UTR_5_PRIME"="5' UTR"
                           ))

data.df <- as.data.frame(table(calls.all$tumor_id, calls.all$class))
colnames(data.df) <- c("sample", "variant_class", "count")

ggplot(data = data.df, aes(x = sample, y = count, fill = variant_class)) + 
  geom_bar(stat = "identity", width = 0.6) + 
  geom_text(aes(label=count), vjust=-0.25) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_discrete(name = "Variant Class")

```

## Allele frequency

```{r}
library(gridExtra)
library(gtable)
library(ggplot2)

# for each sample, create AF density plot with vertical at peak value
AF.plots <- vector('list', length(unique(calls.all$tumor_id)))
for (i in seq_along(unique(calls.all$tumor_id))) {
  temp <- subset(calls.all, calls.all$tumor_id == unique(calls.all$tumor_id)[i])
  
  num_mutations <- nrow(temp)
  
  # identify peak value for current sample
  max_y_density <- which.max(density(temp$allele_freq_tumor)$y)
  max_x_intercept <- density(temp$allele_freq_tumor)$x[max_y_density]
  max_y_intercept <- density(temp$allele_freq_tumor)$y[max_y_density]
  
  print(max_y_intercept)
  
  AF.plots[[i]] <- ggplot(temp, aes(as.numeric(allele_freq_tumor))) + 
    geom_density() +
    geom_vline(xintercept = max_x_intercept, col="red", lty=2) +
    xlab("Allele frequency (%)") + ylab("Density") +
    annotate("text", 
             y = max_y_intercept+0.2*max_y_intercept,
             x = max(temp$allele_freq_tumor),
             label = paste("Peak AF: ", round(max_x_intercept, digits = 2), "%", sep = ""),
             hjust = 1) + 
    theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
    ylim(0, max_y_intercept+0.25*max_y_intercept) +
    ggtitle(label = paste(temp$tumor_id, " (n = ", num_mutations, ")", sep = ""))
}
#do.call("grid.arrange", c(AF.plots, ncol=1))
grid.arrange(grobs = AF.plots, ncol=3, bottom = "Allele frequency (%)", left = "Density")

#y = max(density(temp$allele_freq_tumor)$y),

# plot all samples
p <- ggplot(calls.all, aes(as.numeric(allele_freq_tumor), colour = tumor_id)) + 
  geom_density() + 
  xlab ("Allele frequency (%)") + 
  ylab("Density")

# faceted plot (one distribution per sample)
p + facet_grid(tumor_id ~ ., scales = "free")

# or organize plots into 2 columns
p + facet_wrap(~ tumor_id, ncol=2)

```
